# 도메인 특화 언어 (Domain-Specific Language, DSL)

도메인 특화 언어는 특정 기능이나 영역을 위해 만들어진 언어를 말한다. (직접 만들어보기 전까지는 잘 이해가 안됨.) 

- 소프트웨어 설정 묘사
- 테스트 명세 지정
- 작업 흐름 규칙 정의 
- 데이터 조작 
- UI 설계

**DSL 의 장점은 단순함인데. 문제를 해결할 때 문제가 속한 용여로 기술 할 수 있다는 점이다.**

여기서는 DSL 을 설계할 때 코틀린을 어떻게 쓰면 되는지를 소개한다. 

배우는 내용은 다음과 같다. 

- 연산자 오버로딩 

- 위임 프로퍼티 

- 고차 함수와 DSL 

## 연산자 오버로딩 

**연산자 오버로딩은 `+, -, *, /` 등의 코틀린 내장 연산자에 대해서 새로운 의미부여를 할 수 있는 언어 기능이다.** 

예로 `+` 를 보면 `+` 는 숫자 앞에서는 수 두 개를 더하는 연산이지만, 문자열 연산에서는 연결을 뜻하는 연산이고 컬렉션에서는 원소를 맨 뒤에 붙이는 연산이다.

이렇게 하나의 연산이 다양한 의미를 가질 수 있도록 하는게 `+` 가 오버로딩 되어있기 떄문이다.

**코틀린에서 연산자 오버로딩을 적용하고 싶다면 멤버 함수나 확장 함수에 `operator` 를 붙이면 된다.**

```kotlin
operator fun String.times(n: Int) = repeat(n)
```

- `times` 라는 함수는 연산자 `*` 에 해당하고 이를 확장함수로 정의했다. 

- (연산자에 해당하는 함수 이름을 알아둬야 할 듯.)

**함수를 쓰는 대신에 연산자를 쓰는 경우가 있을 거 같은데 좀 더 직관성이 있어 보인다면 연산자를 정의해서 써보는게 좋은듯.**

- `next()` 라는 함수 호출 대신에 `++` 연산자 를 쓴다던지. 

- (함수 자체가 직관적이라면 연산자를 안쓰지 않을까? `contains()` 의 연산자는 `a in b` 이런식으로 표현되는데 `contains` 자체가 가독성이 좋아서 안쓸듯.`operator` 키워드 없이 그냥 `contains` 자체 메소드를 재정의하는 것도 가능하고)  

### 단항 연산 

오버로딩 할 수 있는 단항 연산들을 보자. 이걸로는 `전위 +, -, !` 가 있다. 

**단항 연산자는 아무 파라미터도 받지 않고 함수 반환 타입이 단항 연산의 반환 타입이 되는 걸 말한다.**

**컴파일러는 이러한 단항 연산자를 적절한 함수 호출로 변환해준다. 우리는 이 함수를 `operator` 를 통해서 재정의해주면 된다.**

- `+e` 는 `e.unaryPlus()` 로 변경된다. 

- `-e` 는 `e.unaryMinus()` 로 변견된다. 

- `!e` 는 `e.not()` 으로 변경된다.

`not` 연산을 재정의 하는 예제로는 보색 관계를 표현하는 것이 있다.

```kotlin
enum class Color {
    BLACK, RED, GREEN, BLUE, YELLOW, CYAN, MAGENTA, WHITE;
    
    operator fun not() = when (this) {
        BLACK -> WHITE
        RED -> CYAN
        GREEN -> MAGENTA
        BLUE -> YELLOW
        WHITE -> BLACK
        CYAN -> RED
        MAGENTA -> GREEN
        YELLOW -> BLUE
    }
}
```

또 다른 예제로는 `not` 을 제네릭을 포함한 확장 함수로 정의함으로써 어떠한 타입이 올 수 있도록 하는 연산을 제공해주는 것도 가능하다. 

```kotlin
fun isShort(s: String) = s.length <= 4 

fun main() {
    val data = listOf("abc", "abcde", "abcd", "abcdef", "ab")
    
    println(data.count(::isShort))
    println(data.count(!::isShort))
}

operator fun <T> ((T) -> Boolean).not(): (T) -> Boolean = { !this(it)}
```

- 어떠한 타입의 함수 호출에 대한 `not` 연산자를 정의한 것. 
- `(T) -> Boolean` 이 T 타입에 대한 함수 호출을 말하고 반환 값이 Boolean 이라는 걸 말한다.
- `((T) -> Boolean).not()` 이 T 타입에 대한 함수 호출에 대한 `not()` 연산을 정의한 걸 말한다. 
- 반환 티입이 `(T) -> Boolean` 인 것은 `count()` 가 `predicate` 타입을 받기 떄문에 함수 형식으로 반환을 해줘야한다. 
- `this()` 는 함수 호출을 말하고 `it` 는 이 함수 호출의 인자가 하나이므로 이렇게 표현이 가능하다. 
- **물론 이제 `isShort` 대신에 `isNotShort` 를 정의해서 사용할 수 있는데 이러면 변경 포인트가 두 곳이 될 것.**
- **이 예제 괜찮다고 생각함.**

### 증가와 감소 

증가 (++) 와 감소 (--) 같은 경우도 파라미터가 없는 `inc()` 와 `dec()` 함수로 오버로딩 할 수 있다. 

- 이런 함수의 반환 타입은 항상 증가나 감소 이후에도 같은 타입이어야 한다. 

- **일반적으로 사용할 수 있는 케이스는 `enum` 이 있겠다.**

`++` 와 `--` 를 사용하는 예제를 보자.

```kotlin
enum class RainbowColor {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET; 
    
    operator fun inc() = values[(ordinal + 1) % values.size]
    
    operator fun dec() = values[(ordinal - 1) % values.size]
    
    companion object {
        private val values = enumValues<RainbowColor>()
    }
}
```

### 이항 연산 

코틀린에서는 대부분의 이항 연산자를 오버로딩 할 수 있다. 

- `&&` 나 `||`  는 오버로딩 할 수 없다. 

- 참조 동등성 연산자인 `===` 나 `!==` 도 마찬가지로 오버로딩 할 수 없다.

단한 연산과 마찬가지로 정해진 이름의 연산자 함수를 정의하면 되고 가장 큰차이는 왼쪽 피연산자가 수신 객체가 되고 오른쪽 피연산자가 인자로 들어온다는 점이다.

- `a + b` 의 연산자는 `a.plus(b)` 의 함수 호출로 변환된다. 

- `a - b` 의 연산자는 `a.minus(b)` 의 함수 호출로 변환된다. 

- `a * b` 의 연산자는 `a.times(b)` 의 함수 호출로 변환된다. 

- `a / b` 의 연산자는 `a.div(b)` 의 함수 호출로 변환된다. 

- `a % b` 의 연산자는 `a.rem(b)` 의 함수 호출로 변환된다. 

  - 원래는 나머지 연산이 `mod` 였지만 현재는 `rem` 이 대체한다. 

- `a .. b` 의 연산자는 `a.rangeTo(b)` 의 함수 호출로 변환된다. 

- `a in b` 의 연산자는 `b.contains(a)` 의 함수 호출로 변환된다.

- `a !in b` 의 연산자는 `!b.contains(a)` 의 함수 호출로 변환된다. 

- `a < b` 의 연산자는 `a.compareTo(b) < 0` 의 함수 호출로 변환된다. 

- `a <= b` 의 연산자는 `a.compareTo(b) <= 0` 의 함수 호출로 변환된다. 

- `a > b` 의 연산자는 `a.compareTo(b) > 0` 의 함수 호출로 변환된다. 

- `a >= b` 의 연산자는 `a.compareTo(b) >= 0` 의 함수 호출로 변환된다. 

이런 연산 자체가 필요한 유리수를 만드는 시스템에서는 이런 이항 연산 재정의를 할 것 같다. 

- 각 수를 `sign, num, den` 으로 구별해서 필드로 저장해놓고 계산을 때릴 것이니까. 
