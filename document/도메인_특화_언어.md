# 도메인 특화 언어 (Domain-Specific Language, DSL)

도메인 특화 언어는 특정 기능이나 영역을 위해 만들어진 언어를 말한다. (직접 만들어보기 전까지는 잘 이해가 안됨.) 

- 소프트웨어 설정 묘사
- 테스트 명세 지정
- 작업 흐름 규칙 정의 
- 데이터 조작 
- UI 설계

**DSL 의 장점은 단순함인데. 문제를 해결할 때 문제가 속한 용여로 기술 할 수 있다는 점이다.**

여기서는 DSL 을 설계할 때 코틀린을 어떻게 쓰면 되는지를 소개한다. 

배우는 내용은 다음과 같다. 

- 연산자 오버로딩 

- 위임 프로퍼티 

- 고차 함수와 DSL 

## 연산자 오버로딩 

**연산자 오버로딩은 `+, -, *, /` 등의 코틀린 내장 연산자에 대해서 새로운 의미부여를 할 수 있는 언어 기능이다.** 

예로 `+` 를 보면 `+` 는 숫자 앞에서는 수 두 개를 더하는 연산이지만, 문자열 연산에서는 연결을 뜻하는 연산이고 컬렉션에서는 원소를 맨 뒤에 붙이는 연산이다.

이렇게 하나의 연산이 다양한 의미를 가질 수 있도록 하는게 `+` 가 오버로딩 되어있기 떄문이다.

**코틀린에서 연산자 오버로딩을 적용하고 싶다면 멤버 함수나 확장 함수에 `operator` 를 붙이면 된다.**

```kotlin
operator fun String.times(n: Int) = repeat(n)
```

- `times` 라는 함수는 연산자 `*` 에 해당하고 이를 확장함수로 정의했다. 

- (연산자에 해당하는 함수 이름을 알아둬야 할 듯.)

**함수를 쓰는 대신에 연산자를 쓰는 경우가 있을 거 같은데 좀 더 직관성이 있어 보인다면 연산자를 정의해서 써보는게 좋은듯.**

- `next()` 라는 함수 호출 대신에 `++` 연산자 를 쓴다던지. 

- (함수 자체가 직관적이라면 연산자를 안쓰지 않을까? `contains()` 의 연산자는 `a in b` 이런식으로 표현되는데 `contains` 자체가 가독성이 좋아서 안쓸듯.`operator` 키워드 없이 그냥 `contains` 자체 메소드를 재정의하는 것도 가능하고)  

**또 다른 이유로는 연산자가 제공해주는 개념을 다양한 곳에서 쓰고 싶을 때 연산자 오버로딩을 사용할 수 있을 것 같다.** 

- `Boolean` 만 되는 논리 연산자를 `Predicate` 레벨로 옮긴다던지. (= `and`, `or`, `not`)


### 단항 연산 

오버로딩 할 수 있는 단항 연산들을 보자. 이걸로는 `전위 +, -, !` 가 있다. 

**단항 연산자는 아무 파라미터도 받지 않고 함수 반환 타입이 단항 연산의 반환 타입이 되는 걸 말한다.**

**컴파일러는 이러한 단항 연산자를 적절한 함수 호출로 변환해준다. 우리는 이 함수를 `operator` 를 통해서 재정의해주면 된다.**

- `+e` 는 `e.unaryPlus()` 로 변경된다. 

- `-e` 는 `e.unaryMinus()` 로 변견된다. 

- `!e` 는 `e.not()` 으로 변경된다.

`not` 연산을 재정의 하는 예제로는 보색 관계를 표현하는 것이 있다.

```kotlin
enum class Color {
    BLACK, RED, GREEN, BLUE, YELLOW, CYAN, MAGENTA, WHITE;
    
    operator fun not() = when (this) {
        BLACK -> WHITE
        RED -> CYAN
        GREEN -> MAGENTA
        BLUE -> YELLOW
        WHITE -> BLACK
        CYAN -> RED
        MAGENTA -> GREEN
        YELLOW -> BLUE
    }
}
```

또 다른 예제로는 `not` 을 제네릭을 포함한 확장 함수로 정의함으로써 어떠한 타입이 올 수 있도록 하는 연산을 제공해주는 것도 가능하다. 

```kotlin
fun isShort(s: String) = s.length <= 4 

fun main() {
    val data = listOf("abc", "abcde", "abcd", "abcdef", "ab")
    
    println(data.count(::isShort))
    println(data.count(!::isShort))
}

operator fun <T> ((T) -> Boolean).not(): (T) -> Boolean = { !this(it)}
```

- 어떠한 타입의 함수 호출에 대한 `not` 연산자를 정의한 것. 
- `(T) -> Boolean` 이 T 타입에 대한 함수 호출을 말하고 반환 값이 Boolean 이라는 걸 말한다.
- `((T) -> Boolean).not()` 이 T 타입에 대한 함수 호출에 대한 `not()` 연산을 정의한 걸 말한다. 
- 반환 티입이 `(T) -> Boolean` 인 것은 `count()` 가 `predicate` 타입을 받기 떄문에 함수 형식으로 반환을 해줘야한다. 
- `this()` 는 함수 호출을 말하고 `it` 는 이 함수 호출의 인자가 하나이므로 이렇게 표현이 가능하다. 
- **물론 이제 `isShort` 대신에 `isNotShort` 를 정의해서 사용할 수 있는데 이러면 변경 포인트가 두 곳이 될 것.**
- **이 예제 괜찮다고 생각함.**

### 증가와 감소 

증가 (++) 와 감소 (--) 같은 경우도 파라미터가 없는 `inc()` 와 `dec()` 함수로 오버로딩 할 수 있다. 

- 이런 함수의 반환 타입은 항상 증가나 감소 이후에도 같은 타입이어야 한다. 

- **일반적으로 사용할 수 있는 케이스는 `enum` 이 있겠다.**

`++` 와 `--` 를 사용하는 예제를 보자.

```kotlin
enum class RainbowColor {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET; 
    
    operator fun inc() = values[(ordinal + 1) % values.size]
    
    operator fun dec() = values[(ordinal - 1) % values.size]
    
    companion object {
        private val values = enumValues<RainbowColor>()
    }
}
```

### 이항 연산 

코틀린에서는 대부분의 이항 연산자를 오버로딩 할 수 있다. 

- `&&` 나 `||`  는 오버로딩 할 수 없다. 

- 참조 동등성 연산자인 `===` 나 `!==` 도 마찬가지로 오버로딩 할 수 없다.

단한 연산과 마찬가지로 정해진 이름의 연산자 함수를 정의하면 되고 가장 큰차이는 왼쪽 피연산자가 수신 객체가 되고 오른쪽 피연산자가 인자로 들어온다는 점이다.

- `a + b` 의 연산자는 `a.plus(b)` 의 함수 호출로 변환된다. 

- `a - b` 의 연산자는 `a.minus(b)` 의 함수 호출로 변환된다. 

- `a * b` 의 연산자는 `a.times(b)` 의 함수 호출로 변환된다. 

- `a / b` 의 연산자는 `a.div(b)` 의 함수 호출로 변환된다. 

- `a % b` 의 연산자는 `a.rem(b)` 의 함수 호출로 변환된다. 

  - 원래는 나머지 연산이 `mod` 였지만 현재는 `rem` 이 대체한다. 

- `a .. b` 의 연산자는 `a.rangeTo(b)` 의 함수 호출로 변환된다. 

- `a in b` 의 연산자는 `b.contains(a)` 의 함수 호출로 변환된다.

- `a !in b` 의 연산자는 `!b.contains(a)` 의 함수 호출로 변환된다. 

- `a < b` 의 연산자는 `a.compareTo(b) < 0` 의 함수 호출로 변환된다. 

- `a <= b` 의 연산자는 `a.compareTo(b) <= 0` 의 함수 호출로 변환된다. 

- `a > b` 의 연산자는 `a.compareTo(b) > 0` 의 함수 호출로 변환된다. 

- `a >= b` 의 연산자는 `a.compareTo(b) >= 0` 의 함수 호출로 변환된다. 

이런 연산 자체가 필요한 유리수를 만드는 시스템에서는 이런 이항 연산 재정의를 할 것 같다. 

- 각 수를 `sign, num, den` 으로 구별해서 필드로 저장해놓고 계산을 때릴 것이니까. 

## 중위 연산 

중위 연산으로 쓸 수 있는 것 중에서는 `to` 가 있다. 

```kotlin
val pair1 = 1 to 2 
```

중위 호출을 가능하게 하려면 함수 앞에 `infix` 라는 걸 붙여야 한다.

`infix` 가 붙을 수 있는 함수는 파라미터가 하나인 멤버함수나 확장 함수영 ㅑㅎ나다. 

```kotlin
infix fun <A, B> A.to(that: B): Pair<A, B> Pair(this, that)
```

이를 이용하면 논리곱 (conjunction) 과 논리합 (disjunction) 을 표현하는 중위 연산을 정의하는게 가능하다. 

````kotlin
infix fun <T> ((T) -> Boolean).and(other: (T) -> Boolean): (T) -> Boolean = { this(it) && other(it)}

infix fun <T> ((T) -> Boolean).or(other: (T) -> Boolean): (T) -> Boolean = { this(it) || other(it)}
````

이런 연산을 이용하면 좀 더 간결하게 술어를 만들 수 있다. 

````kotlin
fun isShort(s: String) = s.length <= 4

fun String.isUppercase() = all { it.isUpperCase() }
    
fun main() {
    val data = listOf("abc", "abcde", "abcd", "abcdef", "ab")

    println(data.count( ::isShort and String::isUppercase))
}
````

- **`and` 와 `or` 이라는 연산자를 정의해서 술어를 쪼개서 표현하는게 가능하다. 이렇게 안한다면 `isShort()` 와 `isUppercase()` 를 포함한 함수로 만들어야 할 듯.** 
- **원래는 `Boolean` 값만을 `&&` 나 `||` 같은 논리 연산을 적용하는게 가능한데, 연산자를 재정의해서 함수 단위로 이 개념을 표현하도록 헀다는게 신기하네.**


### 대입 

또 다른 이항 연산 그룹으로 `+=` 와 같은 복합 대입 연산이 있다.

- `+=` 을 불변 컬렉션 타입의 변수에 적용하면 새로운 컬렉션 객체가 생기고 이 객체를 변수애 대입해서 변수 값이 바뀐다. 

- 하지만 이를 가변 컬렉션에 넣으면 그냥 요소만 들어가지 컬렉션 객체 자체는 변경되지 않는다. 

- 근데 가변 컬렉션에 가변 변수를 넣으면 데이터가 변경될 가능성이 있기 떄문에 에러가 난다.

`+=` 와 같은 복합 대입 연산자의 해석 방법을 보자. 

- 먼저 커스텀 복합 대입 연산자가 있는지 확인한다. `+=` 같은 경우는 `plussAssign()` 이 있는지 확인한다. 이걸 이용한다. 

- 복합 대입 연산자가 없다면 이행 연산자의 대입을 사용한다. `+=` 같은 경우는 `+` 이행 연산자를 이용한다.  

- 복합 대입 연산자의 왼쪽 피연산자가 불변이라면 일반 대입문과 이항 연산을 활용한 방식을 사용할 수 없다. 

## 호출과 인덱스로 원소 찾기 

필요한 파라미타와 함께 `invoke()` 함수를 정의하면 값을 함수처럼 사용하는게 가능해진다. 

````kotlin
operator fun <K, V> Map<K,V>.invoke(key: K) = get(key)

fun main() {
    val map = mapOf("I" to 1, "V" to 5, "X" to 10)
    
    println(map("I"))
} 
````

`invoke` 와 `companion object` 를 이용해서 팩토리로 만들 수도 있다.

```kotlin
class Rational(val sign: String, val num: Int, val dem: Int) {
    companion object {
        operator fun invoke(num: Int, den: Int = 1) = Rational("+", num, den)
    }
}

fun main() {
    val rational = Rational(1, 2)
} 
```

- 마치 여러개의 생성자를 가지는 것처럼 사용할 수 있다. 

다음으로 인덱스 연산자를 볼 건데 `array[0]` 이렇게 인덱스 요소를 통해서 호출하는 건 연산자 `get()` 이 있기 때문이다. 

그리고 `array[0] = 10` 과 같이 인덱스를 통해 대입을 할 수 있는 건 연산자 `set()` 이 있기 때문이다. 

이를 정의하면 인덱스 요소를 다루는 것 처럼 쓸 수 있다. 

### 구조 분해 

데이터 클래스에서는  한 번에 여러 프로퍼티로 읽어오고 싶을 때 구조 분해를 사용하는게 가능하다. 

구조 분해 기능을 다른데서 사용하고 싶다면 `componentN()` 이라는 함수를 정의해야한다. 

```kotlin
operator fun RationalRange.component1() = from 
operator fun RationalRange.component2() = to 

fun main() {
    val (from, to) = R(1,3)..R(1,2)
}
```

**구조 분해를 이용하면 한번에 여러 값을 뽑아올 수 있으니까 논리적으로 그룹핑할 때 좋겠다.**


### 이터레이션 

for 문을 ㄷ로고싶다면 `iterator` 함수를 `operator` 로 정의하면 된다.  
